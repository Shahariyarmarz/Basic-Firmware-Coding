/*
DAQ system Codding-----Reading sensor data and store on SD card using data logging
A wearable headset for detecting eye blink
*/
//......................Library FUnctions.............................................
// #include "FS.h"
#include <SPI.h>
#include "SdFat.h"        //Include SD library for SD card operation 
// #include <SdFat.h> 
#include <Arduino.h>  //Include Arduino library....

//.....................SD card pin define.............................................
#define chipSelect    10       //Cheap selector pin ------After activating by esp initiate communication with a given peripheral.
#define SPI_MOSI      11       //Master Out Slave In------Master-out (transmit) and slave-in (receive).
#define SPI_MISO      13       //Master In Slave Out------Slave-out (transmit) and master-in (receive).
#define SPI_SCK       12       //Serial Clock ------------Clock for the bus generated by the controller.


//Battery pin
#define PIN_VBAT 35

// Error messages stored in flash.
#define error(msg) sd.errorHalt(F(msg))

#define FILE_BASE_NAME "Data"


//......................Global variables.............................................
//Variables related to the SD card writing of ADC data
// const uint8_t buttonPin = 42;
volatile uint16_t ADC_buf [10240] = {0}; // variable for buffering the data in the ISR
volatile uint16_t ADC_buf_indx = 0; // index for the data in the ISR
volatile uint8_t ADC_count = 0; // variable to track the number of sampling has happened
volatile uint8_t ADC_copy_flag = 0; // flag for resetting the buffer index

const uint16_t ADC_copy_size = 256; // copy_size x 2 = the size of each data block (in byte) to write in the SD card
const uint16_t ADC_frequency = 1024; // Samping frequency of the ADC data in Hz. This is also the sampling frequency of maternal sensation button press
//Timer interrupt variables
const uint16_t TIMER_PRESCALER = 80;
const uint16_t TIMER_TICK = 1000;	// TimerTick = CPU_CLK_FREQ / (TIMER_PRESCALER * ADC_FREQ) Hard coded because u_16_integer size limit


const uint8_t BASE_NAME_SIZE = sizeof(FILE_BASE_NAME) - 1;
char fileName[13] = FILE_BASE_NAME "00.csv";


const uint8_t buttonPin = 42; // Button is connected to the digital pin 0
const uint8_t button_frequency = 4; // Samping frequency of the button press in Hz. This is used for starting the DAQ only, not in the data sampling

volatile uint8_t button_value_buf = 0; // used to buffer the last value of the button press data
volatile uint16_t long_button_press_count = 0; // variable to track the length of button press



// SD card variables
SdFat sd;

// Log file.
SdFile file;

/////Timer interrupt variable
hw_timer_t* Timer0_Cfg = NULL;


//////Remaining part Timer related variables

const uint16_t timer3_freq = ADC_frequency; // Frequency of the Timer3 in Hz. This is also the sampling frequency of ADC ports


const float battery_threshold = 3.33; // this variable defines the level of the battery necessary to turn on the DAQ system
const uint8_t button_press_threshold = 3; // minimum time duration (s) of button press necessary to start/stop the DAQ

volatile uint8_t start_flag = 1; // flag to indicate the data recording start and stop conditions
volatile uint8_t stop_flag = 0; // flag to indicate the data recording start and stop conditions
uint8_t low_battery_flag = 0; // This flag indicates the battery level is below the threshold

// const uint8_t LED_Red = 6; // Pin assigned for the red LED

const uint8_t led_red = 00;
const uint8_t led_yellow = 45;


void set_pinMode(void); // Function to set the pin modes
void battery_check (void); // Function to check battery level
void set_SD_card(void); // function to initialize SD card
void blink_LED_RED(void); // this function blinks the Yellow lED 3 times
void blink_LED_Yellow (void); // this function blinks the Red LED 3 times
void DAQ_start (void); // Function to check the stating condition of the device
void read_analog_sensors(void); // function to start the analog reading
// void timer3_Callback(void); // callback function for timer3
// void TC3_Handler(void); // function related to the timer3
// void start_timer (int timer_freq); // this function starts the timer



//timerinterrupt and start ADC data reading function
void IRAM_ATTR Timer0_ISR()
{
    void read_analog_sensors();
    // digitalWrite(LED, !digitalRead(LED));
}





void setup() {
  // initialize serial communication at 115200 bits per second:
  Serial.begin(115200);
  
  //set the resolution to 12 bits (0-4096)
  analogReadResolution(12);
  analogSetAttenuation(ADC_11db);
  set_pinMode();
  //Timer interrupt implementation functions
  Timer0_Cfg = timerBegin(0, TIMER_PRESCALER, true); // timerBegin(timer, prescaler, counUp)
  timerAttachInterrupt(Timer0_Cfg, &Timer0_ISR, true);
  timerAlarmWrite(Timer0_Cfg, TIMER_TICK, true);// timerAlarmWrite(timer, TimerTick, autoReload)
  timerAlarmEnable(Timer0_Cfg);
  //Battery check

  battery_check (); // Checks the battery level  
  if (low_battery_flag == 1) {
    while (analogRead(PIN_VBAT) <= battery_threshold); // Program will wait here until the battery level is above the threshold value
    blink_LED_Yellow (); // this function blinks the yellow LED 3 times and then turns it off
    digitalWrite(led_yellow, HIGH); // Yellow LED is turned on
    low_battery_flag == 0; // clears the low battery flag
  }

  set_SD_card();
  while (start_flag) { // this loop will only be executed once- the first time the device is started. Program will stuck in this loop until the DAQ starts and clears the start_flag
    DAQ_start();// Function to check if the button is pressed for more than the threshold duration to start the device. The start_flag is cleared when the DAQ is started
  }



}



void loop() {

  //---------------------------------- Checking the stop condition ------------------------------------
 if (stop_flag) {
    /* First the timer is turned off so that data sampling is stopped.
       Then the LED will blink 6 times and the program will wait until the button is released.
       The LED will turn off.
       SD card is initialized again to set the file names.
       Some of the global variables which are used inside the DAQ functions are reset to 0.
       Program enters into a while loop to wait for the DAQ to start and stop_flag to clear.
    */
    // zt3.enable(false); // disable the timer need  to correction of timer
    blink_LED_RED(); // blinks red LED and then enters into the while loop so that blinking doesn't happen again
 
    while (digitalRead(buttonPin)); // the program won't move until the button is unpressed
    digitalWrite(led_red, LOW); // turn off the LED

    set_SD_card(); // Initializes the SD card and also finds the unused fileName
    ADC_buf_indx = 0; // index for the data in the ISR
    ADC_count = 0; // variable to track the number of sampling has happened
    ADC_copy_flag = 0; // flag for resetting the buffer index

    while (stop_flag) {
      DAQ_start(); // wait for the start of the device again. stop_flag is cleared inside this function when the starting condition is met.
    }
  }
  else {
  /* First the data file is opened for appending data.
       A while loop is run for a predefined period to copy the ADC data in a buffer and the write that to SD card.
       SD card writing is done in chuncks (multiple of 512 bytes) to reduce the writing lag time.
       Writing is done in binary format.
       Data file is closed after the predifined period is elasped.
    */

    // Open the data file in the SD card
    if (!file.open(fileName, O_WRONLY | O_CREAT | O_APPEND)) {
      error("file.open");
    }

    uint16_t ADC_buf_copy [ADC_copy_size]; // variable to contain (ADC_copy_size x 2) bytes copy of the buffer
    long SD_card_close_interval = 600000; // sampling time in ms
    long loop_start = millis(); // variables to store times in miliseconds



    // Loop for writing data to SD card for 600s
    while ((millis() - loop_start) <= SD_card_close_interval) {

      if ((ADC_buf_indx >= ADC_copy_size) && (ADC_copy_flag == 0)) { // Happens (timer3_freq * 8/ADC_copy_size) times in every second

        //        long start_time = micros();

        // Loop for copying (copy_size*2) bytes from the ADC_buf
        for (uint16_t z = 0; z < ADC_copy_size; z++) {
          ADC_buf_copy [z] = ADC_buf [z];
        }

        ADC_copy_flag = 1; // set the copy_falg to inform that a copying operation has been completed
        file.write((const uint8_t *)&ADC_buf_copy, sizeof(ADC_buf_copy)); // type casting the buf_copy to uint8_t type and writing to the SD card

        //        Serial.println(micros() - start_time);
      }
      if (stop_flag)
        break;
    }
    file.close(); // Closing the data file for the ADC data



  }



}



// void read_analog_sensors();

































